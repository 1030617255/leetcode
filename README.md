刷题记录
============

2020.1.27 4:28   Leetcode315
------------------
这个题乍一看用二叉搜索树做不难。但自己折在了“Count += root -> count + 1;“
我写成了"cout = root-》count+1；insert_node = count" 这其实是难点所在。
每个节点的count都记录了左子树所有的节点的个数。这也是二叉搜索树的精华所在。可以
直接跳到下一个大于当前节点的位置。那这样看来count的值一定是+=计算下来的.
二叉搜索树示意：
 （8 9 10 （5 6 7））可以看到，每个节点左子树都记到了碰到比自己大的地方就停止了。
 所以不会出现我想的重复加的情况。count(7) = 2; count(10) = 2;所以如果下一个是11
 的话，计算过程是2+1+2+1 = 5;
 
2020.1.27 23:31   leetcode542
--------------------
首先说一句自己太菜了，这么简单地题做了很长时间
这道题跟迷宫题很像，只不过这道题相当于是多个出口。
先把所有的0全都压入队列，然后逆向bfs
判断是否入队列的条件就看这个点之前有没有入队列过
如果没有如果队列，就一定是1，此时也一定是到达这个位置的最短位置。
这个题学习两点：1.记住方向遍历的简单写法2.二维vector确定大小和初始化的写法

2020.1.28 22:21 leetcode456
-------------------
还是太菜了，试了很多想法要么是超时，要么是错误。想的麻烦了。
最朴素的dp就完事了。n2复杂度。对于每一次内循环，起点是不变的，
只需要更改区间[first,second]的j就可以，改变之前先检查一下，当前的数在
不在区间里。如果在返回true，不再就看是否会让这个上升区间拉长，
可以的话就把second改成当前的nums[j]。初始的first,second可以设置成nums[i]
显然这个做法不是最好的。但思路很清晰。
另一种：问题是在一个整数序列中，有没有一个子序列符合 ai < ak < aj, 其中 i<j<k
所以可以把问题转化成，找到一个元素 aj, 在区间[1, j-1]里有比他小的元素M1，在区间[j+1, n]里也有比他小的元素M2, 并且M2>M1
所以这里需要让M1尽可能小，所以第一步就是维护一个最小前缀值的数组，即aj对应的最小M1
因为有了前缀最小值，所以我们可以很快判断aj和M1的关系，接下来的任务就是找M2。
首先可以想到暴力解，遍历[j+1]到n的每一个数，时间复杂度是O(n^2)，那么有什么办法可以优化这部分，我们可以从数组尾部开始向前维护一个单调递减栈，
对于每一个aj，如果aj>M1，然后在当前栈中找比M1大的最小值，即以M1为最小标准值来维护这个递减栈之后的栈顶元素，如果栈顶元素小于aj，即找到我们所需要的情况
为什么以M1为最小值维护栈不会对后续造成影响
我们先看看最小前缀值数组有什么特征，很容易得出它是一个非递增数组，
后面的元素都小于或等于当前元素，所以如果当前栈里的元素小于 aj 对应的M1，那么肯定也小于a[j-1] 到a[1]对应的M1，所以直接出栈即可。
为什么最后可以直接入栈
在上一步以M1维护栈之后，栈里的元素都是大于M1，此时如果栈顶的最小值小于nums[i],就已经找到我们要的情况，否则的话栈内元素都是大于nums[i]的，直接把nums[i]推进栈，不影响递减。

2020.1.29 17:52 leetcode650
-----------------
水题。但是为什么我换成了尾递归只有，内存反而用的更多了？不理解。

2020.1.30 0:55 leetcode1138
----------------
水题。第一遍直接暴力反向dfs。但后来看了一个解答提了两个字方向。立刻恍然大悟。
就是一个if判断。哎还是太菜了。不能套思路，要活学活用啊！

2020.1.30 19:15 leetcode870
---------------
贪心算法的水题。先把两个数组排序。从最小开始比，如果A[i] > B[i]
就把这个数相互对应，否则就消耗掉一个最大的B，使得这个A利益最大化。
为了找到排序后的要放的位置，对B的数进行了位置标记。

2020.1.31 1:15 leetcode735
-----------
这道题也不难，就是自己写的太啰嗦了。总体来说就是栈。
从左到右扫描，分别记录上升序列，用最大的元素代表这个上升序列。
如果碰撞的话，最大碰不过的话，下面都碰不过了。最大的可以碰过，后面的也就都可以保护。

2020.1.31 22:37 leetcode306
--------------
水题。没用递归，感觉递归不好用，直接用了for循环。还有就是字符串的加法。

2020.2.1 16:48 leetcode287
----------------
这道题没有做出来，虽然想到了用二分，但是没有想到用抽屉原理。对于这种无序的数，
确定一个n长度的序列，随便猜一个这是重复的数t，如果小于等于t的个数>t，则说明
重复的数字一定就在[1,t]之间，否则就在[t+1,n]之间。这就是抽屉原理。

2020.2.1 19:53 leetcode142
----------------
这道题是好题。第一次用快慢指针做循环链表入口问题，以前记得写文法的时候
遇到过判定的问题，直接暴力的在结构体上打标记。。。我再来简单证明一下。
快指针f，慢指针s。f移动速度是s的2倍。有循环时，第一次相遇有如下的结论：
f=2s和f=s+nb(b是循环列表的长度)然后可得s=nb,f=2nb.说明相遇的时候s走了n倍的
环，f走了2n倍的环。如果让指针，定位到环开始位置（任何走到换开始位置的指针的步长
都是a+nb，a是不在循环里的步数），只需将一个指针x定位到head，让他和s指针一起移动，
在环入口时x走了a步，则s走了nb+a步，所以相遇时就一定在循环链表入口了。

2020.2.1 22:39 leetcode41
---------------
这道题的难点在于限制了空间复杂度(O(C))时间复杂度(O(n))
看了解析才会。初始想法当然是弄一个visit数组，看到一个数就visit[i]=1
标记完后从0--nums.size()为下标遍历，第一个没有visited的数就是所得。
但这样空间复杂度就会不满足要求。于是用"桶排序"（第一次听说)就是直接
在原数组的情况下，如果nums[i]!=i+1,就说明他不在原来的位置上。需要
调换nums[nums[i]-1]与nums[i]放到正确的位置，并同时i--，让下一次循环
处理这个新的nums[i],最后扫描数组 第一个不满足 nums[i]==i+1的就是结果。

2020 2.2 22:44 leetcode135
---------------
贪心算法。这个题比较简单。维护一个严格单调递减栈。这个时候的基础和就是这个栈的长度n的
累加求和(n+1)*n/2,之所以说基础和是因为还要考虑边界问题。如果这个时候的边界的最左边a的糖果（也就是
最大值），小于等于上次的最右边b的糖果（也就是最小值），但同时a的得分大于等于b的得分时，就要多给a糖果，
使得满足要求。这样可以保证分发的糖果最小，因为从递减数列的最小的人开始发，而且边界值也得到了保证。

2020 2.3 3:22 leetcode264
-----------------
用动态规划的思路去想，或者不叫dp也行，也可以叫做队列的思路。
把2,3,5指针指向当前可扩展的对应数字a,b,c，然后比较2a,3b,5c最小的就是当前res[n]的值
并相应的吧指针++。同时为了避免重复2a,3b,5c可能会出现重复的情况，所以要用3个if，把三个数都扫描一遍。

2020 2.4 0:47 leetcode1201
------------------
这道题做了很久。哎。把“前n个数里包含几个丑数”都想到写出来了，都没想到用2分来确定这个数。还是对二分不熟悉。
这个题注意一下两点：第一：3个数a,b,c的最小公倍数 a*bc的最小公倍数/gcd(a,bc的最小公倍数),而bc的最小公倍数
是用b*c/gcd(b,c)第二：二分法的应用。

2020 2.3 3:14 leetcode34
------------------
水题。两遍二分就可以找到左右边界。值得注意的是，一般我们总是在二分的时候：if(nums[mid] < target)left = mid+1;
总是把等号加在right那边是有原因的，因为int自动向下取整，比如说对于数组5，7，7，8，8，10，想要查找8，如果判断条件
是if(nums[mid] <= target)left = mid;就会死循环左右指针会卡在4,5.解决办法就是对int向上取整。

20202.5 5:06 leetcode327
--------------
这道题用的归并排序。总结一下几点：
1.归并排序的内容
2.能尽量在循环外赋值就在循环外赋值，找这个超时的点找了一个多小时
3.以后对区间和的题，要有意识的想到前缀和数组，这道题就是先求前缀和数组，然后对前缀和数组归并排序，当两遍排好序归并时
对于每个在左array的元素t，两个指针指向右边开始数组开始位置分别求<lower和<=upper的终点用右边的array的元素-t 差为b，以此来求出满足<lower和<=upper的区间和的终点，做差就是在lower和upper
之间的个数了，而且两个指针不用回溯，因为left对应的数在变大，两个指针对应的数只有变大才可能符合要求。

2020.2.5 21:29 leetcode19
------------------
双指针，一边扫描一个链表倒数第n个结点，先让一个指针p1向前走n个，然后另一个指针p2指向头节点后，移掉最后时候p2指向的就是要删除的节点。

2020.2.6 0:06 leetcode30
--------------------
这道题是哈希和滑动窗口的应用。滑动窗口的长度等于words数组所有单词的总长度。哈希表里存放的是每个单词在words数组里出现的次数。
对s字符串遍历，每次取滑动窗口的大小，对于滑动窗口里的单词，如果可以在滑动窗口开头找到一个单词并且单词对应的哈希值不为0，就可以移动滑动窗口内部的
指针，直到吧滑动窗口遍历完。如果中途没找到单词，就break，说明这个滑动窗口不符合要求，否则这个滑动窗口就是一个答案，滑动窗口开始位置压进vector。

2020.2.6 0:25 leetcode62
---------------
dp水题。

2020.2.6 1:56 leetcode63
----------------
dp水题。

2020.2.6 2:24 leetcode980
-----------------
逆序dfs，一遍过哈哈哈哈哈哈！

2020.2.6 4:50 leetcode5
----------------
总结两点：
1.找回文串就是把串倒过来匹配最长子串。
2.把字符串倒过来之后只是匹配最长字串还不行，可能有这种情况，
aacbdfcaa 这个串和倒过来的串最长字串是aac是不对的
所以还要判断这个时候匹配的串和原来是不是一个位置 i:反转串指针 j原串指针 vv当前最长子串长度 判断他符不符合回文串：
用这个时候的坐标i-vv+1得到回文串在反转串起始位置
如果加上j等于等于总长度-1 就符合条件了。

2020.2.6 17:06 leetcode64
--------------------
dp水题。滚动数组优化。

2020.2.6 21:01 leetcode32
-----------------
这个dp写了块两个小时，不应该。
总体思路是栈加dp，但我的算法的dp感觉有些诡异。
首先确定Maxlength = 等于当前的括号对（也就是1）加上now在加上左括号对之前的挨着的最长的括号对
换句话说，maxlength=1+左括号之前的连续的括号对+当前括号对之间的连续的括号对
now指的是当前存在的最长的括号对 ()()这个时候的now就是2，()(这个时候的now就是0 
当遇到(时，标记上这个左括号之前的最长的连续的括号对为now，存到tag[i]，然后把now请0，然后下标入栈。清0是因为我们maxlength求法的缘故，因为还要加上
括号对之间的，所以必须把(之前的要清0
当遇到)时，栈空是之间将now=0，表示对当前)的下一个符号来说，之前并没有连续的括号对了（因为当前已经不匹配了）。如果栈不空，根据栈顶元素找到
这个元素之前的now，在+1，再+tag[i](把now存在了这里面)然后更新最长的length。

2020.2.8 1:59 leetcode85
----------------
ps:https://www.cnblogs.com/ganganloveu/p/4148303.html这个讲的最好 用这个博主的思路做题会更清晰！！！！！
这个题写了一天。哈哈哈哈哈。自己太浮躁了，被关了太久，沉静不下来学习。明天要改，今天相当于放假了。
这道题最终被我转化成了求最大矩形的题。最大矩形的题在csp2013年出过，我还做来着，可能当时就是用的暴力写的吧。
转换成最大矩形的思路就是对于每一行求最大矩形，没一行的每一位上的数字代表从当前位置向上连续一个个数，然后这个大小就代表了矩形的高度。从而转换成了
求最大矩形。
求最大矩形方法：维护一个严格递增的栈，当大于栈顶元素时就入栈。当小于等于时，需要把所有大于等于当前元素的数出栈。出栈后要更新这个时候的最大矩形的面积。
因为递增，所以高度肯定是刚刚出栈的元素的高度，底边长就是j-stack.top-1，为什么这么求，是因为存在这种情况2，5,4,6,3。5会在中途出栈，当3要插入时，5已经不在
栈中，所以要减去此时的栈顶，也就是要计算3到2的距离，因为不包括3本身（3到后面统一处理），所以要减去1.当弹出一个数后栈空时，说明此时插入的数目前最小，前面没有
小于他的数，所以直接用j*出栈元素高度。插入栈元素完成后，会在栈里保留递增的序列。依次弹出他们，更新最大面积和上面稍有不同，只需要加1 j-stack.pop和(j+1)*
出栈元素高度。因为要包括最后一个数了，因为他最大，一定可以包含在之前的矩形里面。https://blog.csdn.net/zhdl11/article/details/83578152

2020.2.8 18:17 leetcode136
-----------------
异或运算。找出数组出现一次的数字，其他数字都出现了两次。这个时候把所有数字异或就行了。两个相同的数异或是0,0和一个数异或等于这个数。并且异或有交换律。
2^2^1=1,2^1^2=1.保证了正确性。

2020.2.8 18.17 leetcode137
------------------
异或运算。找出数组中出现一次的数字，其他数字出现了三次。这个思路和上面的一样。这个题用的通用解法，136题相当于是本题解法的简化。对于所有数的每各位，
出现1的次数应该是2的倍数或者2的倍数+1,所以那些2的倍数+1的位置就是只出现一次的数字的对应的1的位置。

2020.2.8 18:17 leetcode260
-----------------
这个方法很巧妙。题目“给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。”在一个数组里肯定是找不到的。
要把两个数分到两个数组里，再用上面的异或的方法找。那怎么分数组呢。把所有的数都异或后的结果应该等于那两个出现一次的数的异或。这个时候取lowbit，这个数一定
是这两个数其中一个造成的，肯定是一个数在这个位上是1，一个是0.然后判断所有的数和这个lowbit相与，等于lowbit的在一组，不等于lowbit在一组，这样两个出现一次的
数一定在两个数组里，并且相同的数也一定分在相同的数组里了。然后在运用上面的算法就可以了。

2020.2.9 16:29 leetcode231
---------------
2的幂。判断这个数的lowbit是不是等于本身即可。比较坑的是，为了防止越界，要先把int扩展到long 再进行lowbit，要不取负数操作会越界。原来扩展到long要直接用赋值才行
像这样m=n，m是long，n是int。。。

2020.2.9 17:56 leetcode187
-----------------
朴素做法是滑动窗口+哈希。但是复杂度是10n，可以通过把字符映射成数字的情况，即A：00，C：01，G：10，T：11.每次向左移动两位，看看20bit的数是否之前出现过，
可以减少空间复杂度和时间复杂度。bitset<n>s,相当于开了一个n大小的01数组（有点不太像set），这样可以节省空间，并且可以用作哈希表，可以随机访问，比如说
这次visit了一个数是1，那么就可以s.set(1),就做成visited的哈希了。

2020.2.9 18:56 leetcode70
------------
dp爬楼梯。水题。

2020.2.9 20:41 leetcode72
--------------
编辑距离。用的朴素的二维dp，一遍过。最重要的还是转移方程。总结两点：
1.两层循环，第一层是要改变的word，第二层是模板word2。为了便于写代码，我自己在Word2前面加了
一个井号键，表示空，这样的话遇到这个字符直接等于第一层的word指针的下标之前的字符长度就行了（相当于把word变成空，全部删除即可），这样便于下面写
转移方程，就不用考虑边界问题了。对于word1也是，首先首先处理一下把空串转化成word2的步数。
2.转移方程时，dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1]分别对应替换，删除，插入。如果这个时候i和j指向的字符相等，转移方程就变成了
dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1，dp[i-1][j-1]).

2020.2.10 17:39 leetcode91
-----------------
dp.感觉对这种dp数组是一维的已经全都掌握了？？一遍过。
这个题需要记录两个数组，一个是到目前为止的解码方法dp，一个是记录以当前单个字符结尾的，即当前字符一个数结尾的个数 比如 1 2 dpDan[1]（1是指针，指向数字2）等于1。1232，dpDan[3] = 2,因为
1,2，3,2和12,3,2。初始dp[i]=0,当当前字符不为0时，说明可以以这个单个字符为结尾进行解码，此时dp[i]+=dp[i-1],同时更新dpDan[i-1]=dp[i]。然后看看当前字符
和前一个字符可以不可以组合来作为结尾进行解码，如果可以dp[i]还需要在加上dpDan[i-1](就是相当于直接把他放到了上i-1这个单个字符的后面，个数正好等于dpDan[i-1]）

2020.2.10 21:05 leetcode87
------------------
三维dp。可以当做多维dp的入门题来复习。虽然没写出来。但不想多些思路了，可以看题解。

2020.2.11 16:07 leetcode96
-----------------
dp一遍过。分成左右字数去考虑。如果想递归，就很好做了，只不过是把递归改成递推。n个点的数结构个数=j个点的左子树的结构个数*n-1-j个右子树结构的个数，n-1是
是因为1个点要当根节点，j的范围从0-n-1。

2020.2.11 18:48 leetcode201
-----------------
自己的想法是取每个数的lowbit，设最大的lowbit为t，t假设=10000，则小于在这个1前面的位数不可能有1，因为这个1后面就都是0了。然后一步步求出结果。但是这样
复杂度也很高。看了一个答案说，“可以得出题目其实等价于求m和n从高位开始，有多少位是相同的，这些相同的位组成的数就是答案，”恍然大悟。自己的错误在于
还是没有充分利用题目给的信息，可以看到这些数都是连续的，连续的就一定存在进位，所以从最大数和最小数的最高位相等的位数就是结果了。而我那种方法适用于
不是顺序的情况。所以要充分利用信息。

2020.2.13 0:58 leetcode233
--------------------
这道题不知道为什么写的很有成就感，虽然写了3个小时。很慢。但是第一次用python写题，也是一次过的。
整体思路是dp的思想。一开始想的是从左到右dp，后来怎么算都不对，最后才发现只能从低位到高位dp。
整体的思想是：当前位之后所有的1（比如287，当前位置是8时，就是指87之前所有的1，当前位置是2是就是287之前所有的1）由三部分组成：
拿287举例:Sum(287)=Sum(87)+1*100+2*20.Sum(87)是上一步dp的结果，也就是对应的201-287中的1的个数。1*100对应的是101-199之间的个数。
2*20对应的是0-99，和101-199之间的1的个数（这里只统计101-109后两位的1的个数，所以20*2就可以了，第一位上的1在1*100统计过了），20
怎么来的呢，通过def getInterNum(self,n)这个函数来的，整体思想和上面一样的，在代码里写了。可以找到规律，0:0,10:1,100:20,1000:300,10000,：4000.所以20*2就可以了，第一位上的1在1*100统计过了），20直接
用O1的时间复杂度去获得，节省时间。
当0的时候直接跳过即可，当1的时候需要特殊处理，比如Sum(187)=Sum(87)+(1+87)+1*20,中间的一项变了，是因为不能100了，因为最多只能到达187,188-199的后两位
的1不能统计。
哦对，这个题我一开始就看到了连续这个条件，算是吸取了上个题的教训。