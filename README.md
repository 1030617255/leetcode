刷题记录
============

2020.1.27 4:28   Leetcode315
------------------
这个题乍一看用二叉搜索树做不难。但自己折在了“Count += root -> count + 1;“
我写成了"cout = root-》count+1；insert_node = count" 这其实是难点所在。
每个节点的count都记录了左子树所有的节点的个数。这也是二叉搜索树的精华所在。可以
直接跳到下一个大于当前节点的位置。那这样看来count的值一定是+=计算下来的.
二叉搜索树示意：
 （8 9 10 （5 6 7））可以看到，每个节点左子树都记到了碰到比自己大的地方就停止了。
 所以不会出现我想的重复加的情况。count(7) = 2; count(10) = 2;所以如果下一个是11
 的话，计算过程是2+1+2+1 = 5;
 
2020.1.27 23:31   leetcode542
--------------------
首先说一句自己太菜了，这么简单地题做了很长时间
这道题跟迷宫题很像，只不过这道题相当于是多个出口。
先把所有的0全都压入队列，然后逆向bfs
判断是否入队列的条件就看这个点之前有没有入队列过
如果没有如果队列，就一定是1，此时也一定是到达这个位置的最短位置。
这个题学习两点：1.记住方向遍历的简单写法2.二维vector确定大小和初始化的写法

2020.1.28 22:21 leetcode456
-------------------
还是太菜了，试了很多想法要么是超时，要么是错误。想的麻烦了。
最朴素的dp就完事了。n2复杂度。对于每一次内循环，起点是不变的，
只需要更改区间[first,second]的j就可以，改变之前先检查一下，当前的数在
不在区间里。如果在返回true，不再就看是否会让这个上升区间拉长，
可以的话就把second改成当前的nums[j]。初始的first,second可以设置成nums[i]
显然这个做法不是最好的。但思路很清晰。
另一种：问题是在一个整数序列中，有没有一个子序列符合 ai < ak < aj, 其中 i<j<k
所以可以把问题转化成，找到一个元素 aj, 在区间[1, j-1]里有比他小的元素M1，在区间[j+1, n]里也有比他小的元素M2, 并且M2>M1
所以这里需要让M1尽可能小，所以第一步就是维护一个最小前缀值的数组，即aj对应的最小M1
因为有了前缀最小值，所以我们可以很快判断aj和M1的关系，接下来的任务就是找M2。
首先可以想到暴力解，遍历[j+1]到n的每一个数，时间复杂度是O(n^2)，那么有什么办法可以优化这部分，我们可以从数组尾部开始向前维护一个单调递减栈，对于每一个aj，如果aj>M1，然后在当前栈中找比M1大的最小值，即以M1为最小标准值来维护这个递减栈之后的栈顶元素，如果栈顶元素小于aj，即找到我们所需要的情况
为什么以M1为最小值维护栈不会对后续造成影响
我们先看看最小前缀值数组有什么特征，很容易得出它是一个非递增数组，
后面的元素都小于或等于当前元素，所以如果当前栈里的元素小于 aj 对应的M1，那么肯定也小于a[j-1] 到a[1]对应的M1，所以直接出栈即可。
为什么最后可以直接入栈
在上一步以M1维护栈之后，栈里的元素都是大于M1，此时如果栈顶的最小值小于nums[i],就已经找到我们要的情况，否则的话栈内元素都是大于nums[i]的，直接把nums[i]推进栈，不影响递减。

20201.29 17:52 leetcode650
-----------------
水题。但是为什么我换成了尾递归只有，内存反而用的更多了？不理解。