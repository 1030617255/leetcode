刷题记录
============

2020.1.27 4:28   Leetcode315
------------------
这个题乍一看用二叉搜索树做不难。但自己折在了“Count += root -> count + 1;“
我写成了"cout = root-》count+1；insert_node = count" 这其实是难点所在。
每个节点的count都记录了左子树所有的节点的个数。这也是二叉搜索树的精华所在。可以
直接跳到下一个大于当前节点的位置。那这样看来count的值一定是+=计算下来的.
二叉搜索树示意：
 （8 9 10 （5 6 7））可以看到，每个节点左子树都记到了碰到比自己大的地方就停止了。
 所以不会出现我想的重复加的情况。count(7) = 2; count(10) = 2;所以如果下一个是11
 的话，计算过程是2+1+2+1 = 5;
 
2020.1.27 23:31   leetcode542
--------------------
首先说一句自己太菜了，这么简单地题做了很长时间
这道题跟迷宫题很像，只不过这道题相当于是多个出口。
先把所有的0全都压入队列，然后逆向bfs
判断是否入队列的条件就看这个点之前有没有入队列过
如果没有如果队列，就一定是1，此时也一定是到达这个位置的最短位置。
这个题学习两点：1.记住方向遍历的简单写法2.二维vector确定大小和初始化的写法

2020.1.28 22:21 leetcode456
-------------------
还是太菜了，试了很多想法要么是超时，要么是错误。想的麻烦了。
最朴素的dp就完事了。n2复杂度。对于每一次内循环，起点是不变的，
只需要更改区间[first,second]的j就可以，改变之前先检查一下，当前的数在
不在区间里。如果在返回true，不再就看是否会让这个上升区间拉长，
可以的话就把second改成当前的nums[j]。初始的first,second可以设置成nums[i]
显然这个做法不是最好的。但思路很清晰。
另一种：问题是在一个整数序列中，有没有一个子序列符合 ai < ak < aj, 其中 i<j<k
所以可以把问题转化成，找到一个元素 aj, 在区间[1, j-1]里有比他小的元素M1，在区间[j+1, n]里也有比他小的元素M2, 并且M2>M1
所以这里需要让M1尽可能小，所以第一步就是维护一个最小前缀值的数组，即aj对应的最小M1
因为有了前缀最小值，所以我们可以很快判断aj和M1的关系，接下来的任务就是找M2。
首先可以想到暴力解，遍历[j+1]到n的每一个数，时间复杂度是O(n^2)，那么有什么办法可以优化这部分，我们可以从数组尾部开始向前维护一个单调递减栈，
对于每一个aj，如果aj>M1，然后在当前栈中找比M1大的最小值，即以M1为最小标准值来维护这个递减栈之后的栈顶元素，如果栈顶元素小于aj，即找到我们所需要的情况
为什么以M1为最小值维护栈不会对后续造成影响
我们先看看最小前缀值数组有什么特征，很容易得出它是一个非递增数组，
后面的元素都小于或等于当前元素，所以如果当前栈里的元素小于 aj 对应的M1，那么肯定也小于a[j-1] 到a[1]对应的M1，所以直接出栈即可。
为什么最后可以直接入栈
在上一步以M1维护栈之后，栈里的元素都是大于M1，此时如果栈顶的最小值小于nums[i],就已经找到我们要的情况，否则的话栈内元素都是大于nums[i]的，直接把nums[i]推进栈，不影响递减。

2020.1.29 17:52 leetcode650
-----------------
水题。但是为什么我换成了尾递归只有，内存反而用的更多了？不理解。

2020.1.30 0:55 leetcode1138
----------------
水题。第一遍直接暴力反向dfs。但后来看了一个解答提了两个字方向。立刻恍然大悟。
就是一个if判断。哎还是太菜了。不能套思路，要活学活用啊！

2020.1.30 19:15 leetcode870
---------------
贪心算法的水题。先把两个数组排序。从最小开始比，如果A[i] > B[i]
就把这个数相互对应，否则就消耗掉一个最大的B，使得这个A利益最大化。
为了找到排序后的要放的位置，对B的数进行了位置标记。

2020.1.31 1:15 leetcode735
-----------
这道题也不难，就是自己写的太啰嗦了。总体来说就是栈。
从左到右扫描，分别记录上升序列，用最大的元素代表这个上升序列。
如果碰撞的话，最大碰不过的话，下面都碰不过了。最大的可以碰过，后面的也就都可以保护。

2020.1.31 22:37 leetcode306
--------------
水题。没用递归，感觉递归不好用，直接用了for循环。还有就是字符串的加法。

2020.2.1 16:48 leetcode287
----------------
这道题没有做出来，虽然想到了用二分，但是没有想到用抽屉原理。对于这种无序的数，
确定一个n长度的序列，随便猜一个这是重复的数t，如果小于等于t的个数>t，则说明
重复的数字一定就在[1,t]之间，否则就在[t+1,n]之间。这就是抽屉原理。

2020.2.1 19:53 leetcode142
----------------
这道题是好题。第一次用快慢指针做循环链表入口问题，以前记得写文法的时候
遇到过判定的问题，直接暴力的在结构体上打标记。。。我再来简单证明一下。
快指针f，慢指针s。f移动速度是s的2倍。有循环时，第一次相遇有如下的结论：
f=2s和f=s+nb(b是循环列表的长度)然后可得s=nb,f=2nb.说明相遇的时候s走了n倍的
环，f走了2n倍的环。如果让指针，定位到环开始位置（任何走到换开始位置的指针的步长
都是a+nb，a是不在循环里的步数），只需将一个指针x定位到head，让他和s指针一起移动，
在环入口时x走了a步，则s走了nb+a步，所以相遇时就一定在循环链表入口了。

2020.2.1 22:39 leetcode41
---------------
这道题的难点在于限制了空间复杂度(O(C))时间复杂度(O(n))
看了解析才会。初始想法当然是弄一个visit数组，看到一个数就visit[i]=1
标记完后从0--nums.size()为下标遍历，第一个没有visited的数就是所得。
但这样空间复杂度就会不满足要求。于是用"桶排序"（第一次听说)就是直接
在原数组的情况下，如果nums[i]!=i+1,就说明他不在原来的位置上。需要
调换nums[nums[i]-1]与nums[i]放到正确的位置，并同时i--，让下一次循环
处理这个新的nums[i],最后扫描数组 第一个不满足 nums[i]==i+1的就是结果。

2020 2.2 22:44 leetcode135
---------------
贪心算法。这个题比较简单。维护一个严格单调递减栈。这个时候的基础和就是这个栈的长度n的
累加求和(n+1)*n/2,之所以说基础和是因为还要考虑边界问题。如果这个时候的边界的最左边a的糖果（也就是
最大值），小于等于上次的最右边b的糖果（也就是最小值），但同时a的得分大于等于b的得分时，就要多给a糖果，
使得满足要求。这样可以保证分发的糖果最小，因为从递减数列的最小的人开始发，而且边界值也得到了保证。

2020 2.3 3:22 leetcode264
-----------------
 
把2,3,5指针指向当前可扩展的对应数字a,b,c，然后比较2a,3b,5c最小的就是当前res[n]的值
并相应的吧指针++。同时为了避免重复2a,3b,5c可能会出现重复的情况，所以要用3个if，把三个数都扫描一遍。

2020 2.4 0:47 leetcode1201
------------------
这道题做了很久。哎。把“前n个数里包含几个丑数”都想到写出来了，都没想到用2分来确定这个数。还是对二分不熟悉。
这个题注意一下两点：第一：3个数a,b,c的最小公倍数 a*bc的最小公倍数/gcd(a,bc的最小公倍数),而bc的最小公倍数
是用b*c/gcd(b,c)第二：二分法的应用。

2020 2.3 3:14 leetcode34
------------------
水题。两遍二分就可以找到左右边界。值得注意的是，一般我们总是在二分的时候：if(nums[mid] < target)left = mid+1;
总是把等号加在right那边是有原因的，因为int自动向下取整，比如说对于数组5，7，7，8，8，10，想要查找8，如果判断条件
是if(nums[mid] <= target)left = mid;就会死循环左右指针会卡在4,5.解决办法就是对int向上取整。

20202.5 5:06 leetcode327
--------------
这道题用的归并排序。总结一下几点：
1.归并排序的内容
2.能尽量在循环外赋值就在循环外赋值，找这个超时的点找了一个多小时
3.以后对区间和的题，要有意识的想到前缀和数组，这道题就是先求前缀和数组，然后对前缀和数组归并排序，当两遍排好序归并时
对于每个在左array的元素t，两个指针指向右边开始数组开始位置分别求<lower和<=upper的终点用右边的array的元素-t 差为b，以此来求出满足<lower和<=upper的区间和的终点，做差就是在lower和upper
之间的个数了，而且两个指针不用回溯，因为left对应的数在变大，两个指针对应的数只有变大才可能符合要求。

2020.2.5 21:29 leetcode19
------------------
双指针，一边扫描一个链表倒数第n个结点，先让一个指针p1向前走n个，然后另一个指针p2指向头节点后，移掉最后时候p2指向的就是要删除的节点。

2020.2.6 0:06 leetcode30
--------------------
这道题是哈希和滑动窗口的应用。滑动窗口的长度等于words数组所有单词的总长度。哈希表里存放的是每个单词在words数组里出现的次数。
对s字符串遍历，每次取滑动窗口的大小，对于滑动窗口里的单词，如果可以在滑动窗口开头找到一个单词并且单词对应的哈希值不为0，就可以移动滑动窗口内部的
指针，直到吧滑动窗口遍历完。如果中途没找到单词，就break，说明这个滑动窗口不符合要求，否则这个滑动窗口就是一个答案，滑动窗口开始位置压进vector。

2020.2.6 0:25 leetcode62
---------------
dp水题。

2020.2.6 1:56 leetcode63
----------------
dp水题。

2020.2.6 2:24 leetcode980
-----------------
逆序dfs，一遍过哈哈哈哈哈哈！

2020.2.6 4:50 leetcode5
----------------
更新：字符串不要用这个算法了。这个算法太破了。一点都不形象。算法去看132题。
总结两点：
1.找回文串就是把串倒过来匹配最长子串。
2.把字符串倒过来之后只是匹配最长字串还不行，可能有这种情况，
aacbdfcaa 这个串和倒过来的串最长字串是aac是不对的
所以还要判断这个时候匹配的串和原来是不是一个位置 i:反转串指针 j原串指针 vv当前最长子串长度 判断他符不符合回文串：
用这个时候的坐标i-vv+1得到回文串在反转串起始位置
如果加上j等于等于总长度-1 就符合条件了。

2020.2.6 17:06 leetcode64
--------------------
dp水题。滚动数组优化。

2020.2.6 21:01 leetcode32
-----------------
这个dp写了块两个小时，不应该。
总体思路是栈加dp，但我的算法的dp感觉有些诡异。
首先确定Maxlength = 等于当前的括号对（也就是1）加上now在加上左括号对之前的挨着的最长的括号对
换句话说，maxlength=1+左括号之前的连续的括号对+当前括号对之间的连续的括号对
now指的是当前存在的最长的括号对 ()()这个时候的now就是2，()(这个时候的now就是0 
当遇到(时，标记上这个左括号之前的最长的连续的括号对为now，存到tag[i]，然后把now请0，然后下标入栈。清0是因为我们maxlength求法的缘故，因为还要加上
括号对之间的，所以必须把(之前的要清0
当遇到)时，栈空是之间将now=0，表示对当前)的下一个符号来说，之前并没有连续的括号对了（因为当前已经不匹配了）。如果栈不空，根据栈顶元素找到
这个元素之前的now，在+1，再+tag[i](把now存在了这里面)然后更新最长的length。

2020.2.8 1:59 leetcode85
----------------
ps:https://www.cnblogs.com/ganganloveu/p/4148303.html这个讲的最好 用这个博主的思路做题会更清晰！！！！！
这个题写了一天。哈哈哈哈哈。自己太浮躁了，被关了太久，沉静不下来学习。明天要改，今天相当于放假了。
这道题最终被我转化成了求最大矩形的题。最大矩形的题在csp2013年出过，我还做来着，可能当时就是用的暴力写的吧。
转换成最大矩形的思路就是对于每一行求最大矩形，没一行的每一位上的数字代表从当前位置向上连续一个个数，然后这个大小就代表了矩形的高度。从而转换成了
求最大矩形。
求最大矩形方法：维护一个严格递增的栈，当大于栈顶元素时就入栈。当小于等于时，需要把所有大于等于当前元素的数出栈。出栈后要更新这个时候的最大矩形的面积。
因为递增，所以高度肯定是刚刚出栈的元素的高度，底边长就是j-stack.top-1，为什么这么求，是因为存在这种情况2，5,4,6,3。5会在中途出栈，当3要插入时，5已经不在
栈中，所以要减去此时的栈顶，也就是要计算3到2的距离，因为不包括3本身（3到后面统一处理），所以要减去1.当弹出一个数后栈空时，说明此时插入的数目前最小，前面没有
小于他的数，所以直接用j*出栈元素高度。插入栈元素完成后，会在栈里保留递增的序列。依次弹出他们，更新最大面积和上面稍有不同，只需要加1 j-stack.pop和(j+1)*
出栈元素高度。因为要包括最后一个数了，因为他最大，一定可以包含在之前的矩形里面。https://blog.csdn.net/zhdl11/article/details/83578152

2020.2.8 18:17 leetcode136
-----------------
异或运算。找出数组出现一次的数字，其他数字都出现了两次。这个时候把所有数字异或就行了。两个相同的数异或是0,0和一个数异或等于这个数。并且异或有交换律。
2^2^1=1,2^1^2=1.保证了正确性。

2020.2.8 18.17 leetcode137
------------------
异或运算。找出数组中出现一次的数字，其他数字出现了三次。这个思路和上面的一样。这个题用的通用解法，136题相当于是本题解法的简化。对于所有数的每各位，
出现1的次数应该是2的倍数或者2的倍数+1,所以那些2的倍数+1的位置就是只出现一次的数字的对应的1的位置。

2020.2.8 18:17 leetcode260
-----------------
这个方法很巧妙。题目“给定一个整数数组 nums，其中恰好有两个元素只出现一次，其余所有元素均出现两次。 找出只出现一次的那两个元素。”在一个数组里肯定是找不到的。
要把两个数分到两个数组里，再用上面的异或的方法找。那怎么分数组呢。把所有的数都异或后的结果应该等于那两个出现一次的数的异或。这个时候取lowbit，这个数一定
是这两个数其中一个造成的，肯定是一个数在这个位上是1，一个是0.然后判断所有的数和这个lowbit相与，等于lowbit的在一组，不等于lowbit在一组，这样两个出现一次的
数一定在两个数组里，并且相同的数也一定分在相同的数组里了。然后在运用上面的算法就可以了。

2020.2.9 16:29 leetcode231
---------------
2的幂。判断这个数的lowbit是不是等于本身即可。比较坑的是，为了防止越界，要先把int扩展到long 再进行lowbit，要不取负数操作会越界。原来扩展到long要直接用赋值才行
像这样m=n，m是long，n是int。。。

2020.2.9 17:56 leetcode187
-----------------
朴素做法是滑动窗口+哈希。但是复杂度是10n，可以通过把字符映射成数字的情况，即A：00，C：01，G：10，T：11.每次向左移动两位，看看20bit的数是否之前出现过，
可以减少空间复杂度和时间复杂度。bitset<n>s,相当于开了一个n大小的01数组（有点不太像set），这样可以节省空间，并且可以用作哈希表，可以随机访问，比如说
这次visit了一个数是1，那么就可以s.set(1),就做成visited的哈希了。

2020.2.9 18:56 leetcode70
------------
dp爬楼梯。水题。

2020.2.9 20:41 leetcode72
--------------
编辑距离。用的朴素的二维dp，一遍过。最重要的还是转移方程。总结两点：
1.两层循环，第一层是要改变的word，第二层是模板word2。为了便于写代码，我自己在Word2前面加了
一个井号键，表示空，这样的话遇到这个字符直接等于第一层的word指针的下标之前的字符长度就行了（相当于把word变成空，全部删除即可），这样便于下面写
转移方程，就不用考虑边界问题了。对于word1也是，首先首先处理一下把空串转化成word2的步数。
2.转移方程时，dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1]分别对应替换，删除，插入。如果这个时候i和j指向的字符相等，转移方程就变成了
dp[i][j]=min(dp[i-1][j-1]+1,dp[i-1][j]+1,dp[i][j-1]+1，dp[i-1][j-1]).

2020.2.10 17:39 leetcode91
-----------------
dp.感觉对这种dp数组是一维的已经全都掌握了？？一遍过。
这个题需要记录两个数组，一个是到目前为止的解码方法dp，一个是记录以当前单个字符结尾的，即当前字符一个数结尾的个数 比如 1 2 dpDan[1]（1是指针，指向数字2）等于1。1232，dpDan[3] = 2,因为
1,2，3,2和12,3,2。初始dp[i]=0,当当前字符不为0时，说明可以以这个单个字符为结尾进行解码，此时dp[i]+=dp[i-1],同时更新dpDan[i-1]=dp[i]。然后看看当前字符
和前一个字符可以不可以组合来作为结尾进行解码，如果可以dp[i]还需要在加上dpDan[i-1](就是相当于直接把他放到了上i-1这个单个字符的后面，个数正好等于dpDan[i-1]）

2020.2.10 21:05 leetcode87
------------------
三维dp。可以当做多维dp的入门题来复习。虽然没写出来。但不想多些思路了，可以看题解。

2020.2.11 16:07 leetcode96
-----------------
dp一遍过。分成左右字数去考虑。如果想递归，就很好做了，只不过是把递归改成递推。n个点的数结构个数=j个点的左子树的结构个数*n-1-j个右子树结构的个数，n-1是
是因为1个点要当根节点，j的范围从0-n-1。

2020.2.11 18:48 leetcode201
-----------------
自己的想法是取每个数的lowbit，设最大的lowbit为t，t假设=10000，则小于在这个1前面的位数不可能有1，因为这个1后面就都是0了。然后一步步求出结果。但是这样
复杂度也很高。看了一个答案说，“可以得出题目其实等价于求m和n从高位开始，有多少位是相同的，这些相同的位组成的数就是答案，”恍然大悟。自己的错误在于
还是没有充分利用题目给的信息，可以看到这些数都是连续的，连续的就一定存在进位，所以从最大数和最小数的最高位相等的位数就是结果了。而我那种方法适用于
不是顺序的情况。所以要充分利用信息。

2020.2.13 0:58 leetcode233
--------------------
这道题不知道为什么写的很有成就感，虽然写了3个小时。很慢。但是第一次用python写题，也是一次过的。
整体思路是dp的思想。一开始想的是从左到右dp，后来怎么算都不对，最后才发现只能从低位到高位dp。
整体的思想是：当前位之后所有的1（比如287，当前位置是8时，就是指87之前所有的1，当前位置是2是就是287之前所有的1）由三部分组成：
拿287举例:Sum(287)=Sum(87)+1*100+2*20.Sum(87)是上一步dp的结果，也就是对应的201-287中的1的个数。1*100对应的是101-199之间的个数。
2*20对应的是0-99，和101-199之间的1的个数（这里只统计101-109后两位的1的个数，所以20*2就可以了，第一位上的1在1*100统计过了），20
怎么来的呢，通过def getInterNum(self,n)这个函数来的，整体思想和上面一样的，在代码里写了。可以找到规律，0:0,10:1,100:20,1000:300,10000,：4000.所以20*2就可以了，第一位上的1在1*100统计过了），20直接
用O1的时间复杂度去获得，节省时间。
当0的时候直接跳过即可，当1的时候需要特殊处理，比如Sum(187)=Sum(87)+(1+87)+1*20,中间的一项变了，是因为不能100了，因为最多只能到达187,188-199的后两位
的1不能统计。
哦对，这个题我一开始就看到了连续这个条件，算是吸取了上个题的教训。

2020.2.13 16:29 leetcodemian64.py
--------------------
挺有意思，想到了肯定用递归，但没想到终止条件怎么写。原来用串联原则。

2020.2.14 18:40 leetcode1349
-----------------
https://www.cnblogs.com/magisk/p/8809922.html 这个是bitset的用法。
这道题想了块一天，一直觉得马上就要做出来了，可以就是dp的含义定义不出来，所以导致不会写。原来是状态压缩。dp[i][j]表示第i行的坐法是j时前i行所容纳的
最大的学生数。首先是找出本行的可行的状态，可行状态表示要放到.的位置并且不能挨着坐。不可行的状态相应的dp值标记为-1.可行的话，再去找上一行与之可行的
分布，这里的可行就是斜着不挨着然后上一行本行也可行。如果找到的话就更新dp[i][j] = max(dp[i][j],dp[i-1][j]+(int)bs.count());

2020.2.15 1:43  leetcode464
----------------
这道题又做了很久，是状态压缩+记忆化搜素。一开始一直不知道怎么记忆化，以为需要记忆的东西不仅是数的使用情况，还有在这种情况下的desiredTotal，其实不用
因为状态直接对应了最大的问题也就是maxChoosableInteger，desiredTotal下的结果，不论desiredTotal多大。所以只需要记录使用的数的情况就行了。用bitset，很好用。
一个用来记录是否被记忆过，一个来记录对应的真值。
整体思路就是深搜，当这个状态被记忆过，就返回相应的真值。否则，挨个使用没用使用过的数，(如果这个数，直接大于了desiredTotal，返回true),把相应的传进来的status
的第i位改变，以及desiredTotal减去i，继续传入dfs，注意这个时候我们要返回值的相反值，因为这个时候相当于是对方在取，如果对方做不成，才相当于我们完成了。

2020.2.15 3:37 leetcode78
----------------
水题。dfs深搜枚举一遍过。

2020.2.15 16:13 leetcode322.py（可当做01背包模板题）
-----------------
记得当时在算法课上的例子。忘了是不是用01背包的dp做的了。如果直接用O（counts^2）会超时，要用01背包思路借。这个是完全背包，完全背包是恰好装满
01背包的转移方程还好写。主要是初始化。如果朴素01背包，就是dp[c+1],全都初始化为0，每次倒着遍历。如果是完全背包，每个物品可以放好多次，dp[0]=0,其他的
初始化为最小值0-x3f3f3f（如果求最大值的话）,然后正着遍历。这个题可以当做模板题。

2020.2.15 17:23 leetcode53.py
--------------------
贪心水题。

2020.2.15 19:41 leetcode474.py （二维费用背包dp）
------------------
二维费用背包dp。写了3道题01背包，我觉得最关键的就是找到那个是容量，那个是价值，那个是物品标号。不要把容量和价值搞混了。像这道题，我一直吧01的个数当做
了价值，其实他是容量，而每个数的价值是1，他的二维重量就是0的个数和1的个数。

2020 2.16 19:58 leetcode5342.cpp(贪心好题，要常复习）
--------------
第一次参加周赛，比较失败，继续努力。这是一道贪心的好题，我的思路想出来了，但是没想好用什么数据结构。
代码里的思路是这样的：首先明确一点：
对于同时开始的任务，我们会选择先做结束时间早的，这样可以把机会留个结束时间完的任务做。这个简单证明一下。
如果不是先做结束早的，就可能会错过当前结束时间早的，而少做任务。
然后我们看这道题，我们遍历每一天，我们也选择对于当前来说结束时间早的，，因为对于当前来说，那些之前开始的任务和今天开始没有区别，所以就可以把上面的
贪心的思想套用过来了。数据结构选择优先队列。但我没想到的是，怎么动态的选择对于当前天来说最早结束的会议？总不能每一天都排序吧。
原来是提前用On的时间算好每个时间点开始的会议的序号，然后从大到小遍历每个时间点，把当前时间点开始的结束时间压入队列（队列里还有之前开始的会议的结束点，都看作
是现在开始的），然后让小于当前时间点的结束点出队列，选择最小的结束点。然后ans++,出队列，继续遍历时间点。

2020 2.16 21:17 leetcode5343.cpp(fuck 应该先做这题的，很好写，还是hard？）
---------------------
这道题好简单。先排序，从大到小反着求，自己反向看是不是可以求出全1就可以了，为什么是hard呢？？
对，这个题需要总结的是优先队列的排序，以前总是写成struct，把数据当做struct里的属性，然后重载<，学到一种新的pair的写法，重载()，在代码里。

2020 2.17 19:05 leetcode316.cpp
----------------------
贪心。首先确定所以出现的字母，然后记录每个字母出现的位置。然后在出现的子母中，从a-z遍历，如果当前字母的出现比某一个字母的最后出现的坐标还要大，则
这个位置不能把当前字母加进来，（举例cab，会先遍历a如果把a加进来，就会让c在a的后面，会打乱顺序了）因为会打乱相对位置，所以要向下遍历字母，直到当前字母的
最小坐标不会大于还没有出现过的最大坐标（cabc,这时a可以加入),当把a加入后，就要把a之前的字母从vector里删掉。

2020.2.17 19:34 leetcode61.cpp
-----------------
旋转链表，双指针，水题。

2020.2.18 2:00 leetcode97.cpp
------------------
二维dp。按理说这题应该会的。失误！要复习!
整天思路就是dp[i+1][j+1]表示s2的前i+1个字符和s1前j+1个字符能否组成s3前i+j+2个，转移方程是dp[i+1][j+1] = (dp[i][j+1]&&s2[i]==s3[i+j+1] )
||(dp[i+1][j]&&s1[j]==s3[i+j+1] );意思是当前能否成功取决于任意两个情况成立:要么s2前i个字符和s1前j+1个字符可以拼成s3，同时s2第i+1个字符等于s3的第i+j+2个字符
或者要么s2前i+1个字符和s1前j个字符可以拼成s3，同时s1第j+1个字符等于s3的第i+j+2个字符。
仔细想了想，自己没做出来的原因是被交替出现糊弄了，或者是根本因为交替出现就没想到这种dp，其实只要初始状态保证了交替出现，递推下来就都可以保证交替出现了。
这也是很重要的一点，所以以后要想初始情况满足，这里的初始情况就是当一个字符串为空，另一个不为空时，假设不空为s2，就匹配s2前缀和s3前缀最长的是true，当匹配到
不相等时直接跳出循环，后面的都是false，这其实就保证了交替出现的定义了。

2020.2.18 17:34 leetcode115.cpp
---------------------
一边过。二维dp。主要就是转移方程。首先还是要考虑边界，也就是dp的两个维度多开一个，dp[0][0]表示都是空串的情况。
dp[i][j]表示s前j个字符包含多少个t的前i个字符。转移方程是 如果t[i-1]==s[j-1],dp[i][j]=dp[i-1][j-1]+dp[i][j-1];如果不等， dp[i][j] = dp[i][j-1];
不等的情况好解释，就不解释了。解释第一种情况。当相等时，可以把s[j-1]当作是最后一个匹配的字符，相当于直接在dp[i-1][j-1]的匹配情况下结尾追加了一个字符。
当不考虑s[j-1]时，也就是s的前j-1个字符可以包含多少个t的前i个字符，也就是dp[i][j-1],把两者相加即可。

2020.2.19 2:33 leetcode321.cpp（错）
---------------
这道题不会做，很有挫败该。做了很久很久很久，做错了。总结两天，第一个两个字符串按字典序混合，使结果最大的函数。第二个求一个序列包含k长度子串的
字典序最大的函数。

2020.2.19 16:19 leetcode330.cpp （错）
--------------------
贪心题。代码里的注释很详细，可以去看代码。核心是一个问题，当当前的可以覆盖的和的范围是[1,n)时，添加一个数m则覆盖范围是[1,n)并[m,m+n).所以每次为了连续，每次都添加最大的数，也就是n，
这样范围就是[1,2n)了。

2020.2.19 17:34 leetcode376.cpp
-------------------
贪心。思路可以看代码写注释了。在不满足交替的情况下相当于把上一个元素出队列，再把这次的元素进队列。举例：比如1,2,5，3,在指向5的时候不是递减了，就应该把2出队列，换成
5，让高低差距尽量大，这就是贪心，有利于后面把小于5而不是小于2的数加进来
正确性：首先把2换成5不会影响现在的结果，只会让结果>=当前结果。那如果在2开始把 2,5看做是交替数列的开头才能得到最大结果呢？这个时候
就相当于把2放缩成了1，结果还是对的。

2020.2.19 19:10 leetcode402.cpp
----------------
贪心。南大夏令营机考原题。哎，现在看这题就很简单了，说明这段时间刷题还是有点进步的。
思路也很简单，O(N)的复杂度，找到第一个递减的数，把他删除掉即可，删除后，要把删除后的字符串的前导0删除，比如1005，把1删除后，在这次循环的末尾要两个0删除
，如果在这次循环中指针已经到达了字符串末尾，说明前面都是递增的，直接删除当前指向的字符即可。

2020.2.20 14:38 leetcode406.cpp
------------------
贪心算法，一遍过。首先想到的是要确定相对位置。就是对于进入ans vector的人，相对位置是不能再变的。本着这条原则去贪心，也就是让身高大的先进，对于
相同升高的，前面人数小的先进。因为对于身高大的来说，后面没有比自己更高的人了，所有后面的人在什么位置，都不会影响我目前在
队列里的相对位置。如果所有元素都保证了进入ans后相对位置不变，那加入所有元素后，自然所处的位置就是最终位置。

2020.2.20 16:22 leetcode435.cpp
-----------
本质就是区间调度问题。主要是区间调度，先选早结束的贪心算法的正确性证明给忘了，这里稍微写一下。
假设早结束的为[1,X] ,这个时候因为这个区间被删除的区间为[2,x2],[3,x3],可以看到这些删除的元素互相之间也是相交的，所以并不会出现因为保留一个
被删除的区间会是最终保留的区间变多的情况，但这个时候我们只证明了保留早结束的区间的策略所获得的最终结果=保留删除的其中一个区间的策略所获得的最终结果，
但是我们选择的策略会尽早结束，给后面区间的开始时间更多地选择，所以此策略是可行的。

2020.2.20 18:07 leetcode452.cpp
-----------------
还是贪心，区间调度问题。只不过这里像[1,2]和[2,3]这样的也需要看成区间相交。

2020.2.20 19:40 leetcode455.cpp
-------------------
贪心水题。每次先发小的饼干给需要小的人。

2020.2.21 2:51 leetcode502.cpp(错）
----------------------
贪心好题。这个思想可能会常用。一开始想用01背包做，但复杂度接受不了。于是想到贪心，但没想到用什么贪心。一开始想从小于等于当前W的需要资金的项目
里面找到收益最高的去贪心，但复杂度也是n2。总的来说就是实现思路不对。设置大顶堆A小顶堆B，大顶堆放入当前可选项目，按照收益排序。小顶堆放入当前不可选
的项目，按照需要资金排序。每次从A里选出收益最高的，也就是队列顶元素，然后出队列，然后将B中现在可选的项目加进A中，重复此操作。
这种思想应该适用于贪心的目标受两种限制，并且这两种限制的方向是相反的，也就是一个越大越好，一个越小越好。

2020.2.21 15:52 leetcode621.cpp(错)
----------------------
这个题只想到了怎么去计算，当间隔足够大的时候安排，当任务数-1>间隔的时候怎么做。当大于的时候整体的时间就是总任务数了，因为相当于不会浪费时间，没有出现
等待时间。具体解释可以看 https://leetcode-cn.com/problems/task-scheduler/solution/ren-wu-diao-du-qi-by-leetcode/ 官方题解的方法三。

2020.2.21 23:08 leetcode630.cpp(错)
-------------------
这道题又做了好久.贪心，错在了怎么贪心上。我想的是先选紧急的，也就是如果事件要完成，最晚需要考虑去做的时间，从小到大排序。如果可以做就做。
不可以做，就从现在已经选择做的是事情里选择占用时间最长的那一个，如果大于当前事件，就换掉，可以缩短当前所用的总时间，为后面的事件多出更多地空挡。
可是正确的做法是按照结束时间早晚排序，后面和我的做法相同。不知道我的为什么不对。

2020.2.22 12:48 leetcode22.cpp
-------------------
回溯算法，一遍过。

2020.2.22 13:21 leetcode120.cpp
---------------------------
二维dp，一遍过。保留到达每个位置上的最小值。滚动数组优化，优化思想和01背包是一样的。

2020.2.23 1:16 
---------------------
卡在双周赛的最后50秒ak。这种事情也可以让我赶上。

2020.2.23 leetcode76.cpp
-------------------
滑动窗口好题！这道题好好总结一下，滑动窗口的题应该就都会了。这个题不仅要记录t中的字母，还有次数
全都用visited数组解决，visited[i] 代表出现次数，未出现的为-1.设置窗口start end
当 碰到t中字母时，记录到visited 并统计这个时候出现字母的种类数（只有当每个字母出现的次数达到要求了种类数才会加1，所以也隐形检查了）是否满足要求，
满足要求的话这是可能不是最终答案，因为这是的start可能还可以向后移动，检查办法是检测相应的visit数组是不是负数，
是负数说明目前这个串中start指向的字母的个数多于要求的个数，然后移动到visited不是负数的地方，这是就是满足要求的串了。

2020.2.23 12:50 leetcode5172.cpp（错）
------------------
这道题要复习，答案的写法很好，数据结构用的也很好。先统计出0-9的个数，然后求所有数字和的膜3的结果，如果==0，直接从达到小输出即可。
如果是1，要么是余数是1的数字多了一个了，要么是余数是2的数字多了两个，先删除余数为1的数字1个，如果没有，那肯定是多了两个余数是2的，删除这2个。
所有数字和的膜3结果=2的情况类似。

2020.3.9 2：10 leetcode5355.cpp
-----------------
倒序建树。感觉不难，不知道为何是hard。已经快20天没做题了。为了赶due，可惜可能赶不上了。另外leetcode刷题超过100道了。

2020.3.9 2：10 leetcode5354.cpp
--------------
同样还是倒序建树。一样的思路，这道题就是medium的了。蜜汁难度设置。

2020.3.9 17:50 leetcode649.cpp
-----------------
贪心。不知道这个题的意义在哪里。这个贪心感觉有点勉强。水题。

2020.3.10 18:35 leetcode659.cpp(错)
------------------
贪心。学习的有两点：第一是代码的书写，思路想出来了，但自己写的代码和选的数据结构很啰嗦。第二是还没弄懂，为什么第一策略要选择把这个数作为结尾，
而不是作为一个新的三元组的开头呢？

2020.3.10 21:22 leetcode37.cpp
--------------------
写回溯算法的题的时候心情总是愉悦的，因为总能一遍过。

2020.3.11 1:44 leetcode714.cpp(错)
-------------------
这个题真的不应该错。本想用贪心。但贪心太麻烦了。用dp很容易。每个时刻都有两个状态，持有股票，和不持有股票。
初始状态的hold = -price[0],nothold = 0.当遍历时，更新每个时刻的hold和nothold的值，具体规则就是hold要么不变，要么在之前nothold状态下买入股票，
两者取最大值。nothold要么不变，要么在之前hold的状态下卖出股票，并扣除手续费，取两者最大值。最后返回的是nothold也就是卖出股票状态下的最大值。

2020.3.11 12:07 leetcode121.cpp
------------------------
前缀最小数组，水题。

2020.3.11 13:05 leetcode123.cpp
----------------------
dp。思路和714差不多，只不过每个时刻的状态变为了5个。hold0,hold1,nothold0,nothold1,nothold2.意义分别是，完成0次交易hold股票的最大利润，完成1次交易
hold股票的最大利润，完成0次没有hold，完成1次没有hold，完成2次没有hold。最终结果就是nothold1和nothold2的最大值。转移方程也和上面类似，不多说。

2020.3.11 13:40 leetcode738.cpp
------------------
判断单调递增数字，一遍过。思路：设当前数字长度为m,从低向高位检查，如果当前数字是递增的，返回；如果不是，就把低位n为都变成9，高m-n位数字的大小要减1，
保证变化后的数字不大于变化前的数字，n的变化从1到m变化。

2020.3.12 19:13 leetcode757.cpp
-------------------
贪心。做了很长时间，但最终还是做出来了。我觉得对于这种区间贪心，对于区间的排序很重要，一开始我是让区间的第一个数小的在前面，但这样会造成一种错误的情况
出现，处理起来还挺麻烦的。后来猛地想起为了避免这种情况，按照区间结束小的在前面就可以拒绝这个现象。
算法思路：现对于区间按照第二位的大小排序。对于每个区间，如果当前set已经和这个区间相交2个元素了，continue；否则就设置两个数，在设置这两个数时用的是
贪心策略。我们每次都尽可能选取价值最大的数，也就是这个数，在包含在当前区间情况下，在下面未遍历的区间出现的次数最多。这样我们就要选择，最大的数，
和最大的数-1（如果这个区间只需要1个数了，那么第二个数不用选了，为了写程序方面，设置成一个无效数，比如-100）。为什么这样设置就行呢？因为排序后，
假设x1在下面出现次数最多，那么x1+1的出现次数也一定会等于x1的出现次数。大家可以画图试一试。这样就可以使用2个元素相交最多的区间了。

2020.3.13 1:36 leetcode132.cpp
--------------
这是一个好题。可以总结很多东西。第一个是对于一维dp和多维dp掌握的不好，对于表格式的dp还可以。这道题是个一维dp。
第二点是对于回文串的判断，这道题就是标准答案了，以后就用这个模式求回文串，或者像leetcode5那样的题。

2020.3.13 18:33 leetcode139.cpp
--------------
一维dp题，
单词划分，一遍过。总感觉这题做过，但竟然没有提交记录。

2020.3.13 19:17 leetcode763.cpp
----------------
这个题自己做的不是贪心，就是一个哈希表就解决了，复杂度接近O2，看到网上用On做出来的。学习一下。
第一：先遍历一遍，用字典存储每个字符最后的位置。第二步：从第一个字符开始遍历，每获取一个字符就该字符最后一次出现的位置索引定为当前片段的最后位置，
在达到该位置之前，继续寻找更靠后的最后位置，若达到最后位置之前都没有发现更靠后的最后位置，则将当前最后位置作为一个片段的末尾。
这个思路很好，学习了！

2020.3.14 1:03 leetcode130.cpp
------------
现在世界真的好乱啊，英国已经开始采取群体免疫策略了。这也太疯狂了。我是真的怕了。发达国家莫不是有自己的一套模型？按说他们的科技水平和数学水平应该
比我们高啊？
这道题实在不想debug了，有很多种做法。看了一个答案。非常妙！倒着dfs，也就是从边界的o开始dfs，凡是与边界的o相连的，都是不能被设置成x的，那就在这上面
插上旗子1.最后遍历整个map，为1的还是保持o，其他的都变为x。这是思路非常妙，都是有逆向思维在里面的，和上面那个题一样。学习了！！！

2020.3.14 17:00 leetcode140.cpp
-------------
dp+dfs.思路和139题一样，只不过要记录当前dp[i]可以切分成字典里的单词的时候的位置，也就是使(dp[j]&&dict.find(s[j+1:pos]!=dict.end())成立的j的位置，
然后再用dfs去拼接单词就可以了。简单题。

2020.3.14 21:02 leetcode765.cpp
----------------
一开始感觉很难，但一看数据范围。4-60哈哈哈，这啥算法都能跑通把。如果偏要叫他贪心的话，就是每一步移动都要凑成一对情侣牵手才行。而且可以证明
凑成任意一对即可，不会出现，在当前选择调换x1,x2时，调换x3，x2或者x3，x1会凑成更多地情侣牵手。所以直接for循环，每次凑成一对即可。

2020.3.15 16:03 leetcode5359.cpp(错)也是1383题
-----------------
堆优化。看到这个题的第一个想法是01背包，但一看数据范围便作罢。比赛结束后，又想到会不会是最大矩形的题，但这个和最大矩形还不一样，因为底边长度不是
定值了，正确性就没办法保证了。后来一看题解，竟然这么简单。但自己想不到肯定是有原因的。思路在这：https://www.dreamwings.cn/leetcode1383/5576.html
自己叙述一遍：首先按照效率从大到小去排序，排序的目的就是为了后面保证当我处理当前效率时，效率比我大的就不用处理了，因为是从效率比我大的位置遍历过来的，
用到了一点记忆化的思想。排序后，从大到小遍历，将等于当前效率的工人的速度压进优先队列，这个时候队列里的个数可能会大于k，就把最小的数pop出去，直到等于k。
然后算这n次遍历的最大值，就是结果。复杂度就是，在n次的循环中，每次调整有限队列的时间是logn，所以是nlogn。我觉得想不出来的原因就是没有建模成那种矩形
题的形式。

2020.3.17 1:49 leetcode152.cpp
-------------
这道题是dp，虽然做出来了，但是总感觉代码写的不够简洁。因为写的不对称，如果对于每一个元素无论正负，代码的结构都是一样的，就好了。
看了别人的答案，感觉更清晰。别人是划分最大值和最小值，并不区分这两个值的正负，而我设置的两个变量是最大正值，和最小负值。所以有一点麻烦。
maxDP[i + 1] = max(maxDP[i] * A[i + 1], A[i + 1],minDP[i] * A[i + 1])
minDP[i + 1] = min(minDP[i] * A[i + 1], A[i + 1],maxDP[i] * A[i + 1])
dp[i + 1] = max(dp[i], maxDP[i + 1])
这是转移方程，对于0来说max和min都变成0，初值的max和min都设置成nums[0],从1开始遍历。我发现我非常纠结于变量的初值设置。如果算法过分依赖初值，那肯定
是算法不够好，以后要注意。

2020.3.17 3:08 leetcode767.cpp
-----------------------
贪心。维护一个字母出现个数从大到小的优先队列。每次取出前两个，也就是每次都优先消耗出现次数最多的两个字母。如果消耗完后个数等于0，就不放入队列了，
成功返回条件是队列长度为0，当取不出两个时并且第一个剪完1后不为0时，就是不能互不相邻。这个要注意，排序的时候还要再排一下字母顺序，因为对于相同个数的
，比如aaabbb，他会返回abbaab，所以要规定一下字母顺序就好处理了。
别人的思路：判断是否可以成功返回的条件是，最大的字母个数是否小于(字符串长度-1/2),也就是隔一个放一个字母时，会不会放下这个最大字母，比如aaaaabbb，
在奇数位上放置a，axaxaxax,下次再放就要放到第一个x上，就不能满足。如果小于，开一个和字符串相等大小的字符串长度，就先把字母都放在偶数位上，偶数位放满
再放到基数位上。

2020.3.17 15:51 leetcode174.cpp
--------------------
二维dp，一遍过。倒着dp就可以了，设置右下角的dp值为1就可以，没什么可以总结的。

2020.3.17 17:45 leetcode842.cpp
------------
暴力dfs，一遍过。

2020.3.17 20:49 leetcode128.cpp
----------------
dp思路。不错的思路。总体思想是只关注一条链的两边，在连成线的序列的两边更新此链的长度即可。也想到过这个思路，但怎么定位到两边没想到o1的思路。dp的思想就可以做到。

2020.3.17 23:33 leetcode200.cpp
-----------------------
直接dfs一遍过，碰到1就dfs，然后把所有的连着的1都变成0，然后结果加1。

2020.3.18 13:48 leetcode188.cpp
-------------------
dp。这道题思路和之前的很像。保存交易次数为k次的hold商品的值，和nothold商品的值，转移方程是dp[j][1] = max(dp[j][1],dp[j][0]-prices[i]);
dp[j][0] = max(dp[j][0],dp[j-1][1]+prices[i]);dp[i][0] notholdMax after i times trades,dp[i][1]holdMax after i times trades
注意每次更新dp数组的第一维的范围应该是k和现在遍历的商品数目的最小值，因为进行交易的次数不会大于商品数。

2020.3.18 14:01 leetcode860.cpp
---------------
贪心水题，无需总结。
